<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hicancan的算法笔记0x0101</title>
    <link href="/2024/11/07/0x0101/"/>
    <url>/2024/11/07/0x0101/</url>
    
    <content type="html"><![CDATA[<h1 id="hicancan的算法笔记0x0101"><a href="#hicancan的算法笔记0x0101" class="headerlink" title="hicancan的算法笔记0x0101"></a><strong>hicancan的算法笔记0x0101</strong></h1><blockquote><p><a href="https://www.luogu.com.cn/problem/P1226">洛谷P1226【模板】快速幂</a></p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你三个整数 $a,b,p$，求 $a^b \bmod p$。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入只有一行三个整数，分别代表 $a,b,p$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个字符串 <code>a^b mod p=s</code>，其中 $a,b,p$ 分别为题目给定的值， $s$ 为运算结果。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">2</span> <span class="hljs-number">10</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">2</span>^<span class="hljs-number">10</span> mod <span class="hljs-number">9</span>=<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p><strong>样例解释</strong>：</p><p>$2^{10} &#x3D; 1024$，$1024 \bmod 9 &#x3D; 7$。</p><p><strong>数据规模与约定</strong>：</p><p>对于 $100%$ 的数据，保证 $0\le a,b &lt; 2^{31}$，$a+b&gt;0$，$2 \leq p \lt 2^{31}$。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="思路一：直接计算"><a href="#思路一：直接计算" class="headerlink" title="思路一：直接计算"></a>思路一：直接计算</h3><p>直接计算 $a^b \bmod p$，然后输出结果。<br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b, p;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b; i++)<span class="hljs-comment">//一个一个乘</span><br>        result = (result * a) % p;<br>    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;^&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; mod &quot;</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; result &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试点结果：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032316711.png" alt="202411032316711.png"><br>最后三个测试点TLE了</p><p>分析原因：</p><p>一个一个乘以a，时间复杂度为：$O(b)$，当b很大的时候，时间复杂度会很大，因此我们需要优化。</p><p>没有利用到中间结果，比如如果算到了$a^{100}$,完全可以自乘平方，直接得到$a^{200}$。</p><p>从下至上的想的话，从头开始就自乘：也就是知道了a，就能知道$a^{2}$、$a^{4}$、$a^{8}$、$a^{16}$，最终知道：$a^{2^n}$</p><p>但是：很遗憾$2^{n}$不一定等于$b$，所以我们需要找到最接近$b$的$2^{n}$，也就是$2^{\left[log2(b)\right]}$，然后剩下的指数$(b-2^{\left[log2(b)\right]})$一个一个乘。<br>由此产生了思路二：</p><h3 id="思路二：自乘平方递归"><a href="#思路二：自乘平方递归" class="headerlink" title="思路二：自乘平方递归"></a>思路二：自乘平方递归</h3><h4 id="自乘平方并用-2-left-log2-b-right-找到不超过b的最大2的幂次的指数"><a href="#自乘平方并用-2-left-log2-b-right-找到不超过b的最大2的幂次的指数" class="headerlink" title="自乘平方并用$2^{\left[log2(b)\right]}$找到不超过b的最大2的幂次的指数"></a>自乘平方并用$2^{\left[log2(b)\right]}$找到不超过b的最大2的幂次的指数</h4><p>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b, p;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = a;<br>    <span class="hljs-type">int</span> mindex = <span class="hljs-built_in">floor</span>(<span class="hljs-built_in">log2</span>(b)); <span class="hljs-comment">// 求出不大于b的最大2次幂：mindex</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index = <span class="hljs-number">1</span>; index &lt;= mindex; index++) <span class="hljs-comment">// 自乘平方直至指数到2的mindex次方</span><br>        result = (result * result) % p;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b - (<span class="hljs-number">1</span> &lt;&lt; mindex); i++) <span class="hljs-comment">// 剩下的指数一个一个乘</span><br>        result = (result * a) % p;<br>    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;^&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; mod &quot;</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; result &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试点结果：</p><p><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032316085.png" alt="202411032316085.png"></p><p>仍然有俩个测试点TLE了</p><p>分析原因：<br>剩下的指数还是一个一个乘，而剩下的指数个数为：$$2^{\left[log2(b)\right]}$$<br>如果b比较大，那么比b小的2的最大幂次与b差距的可能的差距的最大值就会越来越大，因此我们利用递归的思想，将剩下的指数作为新的b再进行自乘平方，递归求解。</p><h4 id="优化：递归剩下的指数"><a href="#优化：递归剩下的指数" class="headerlink" title="优化：递归剩下的指数"></a>优化：递归剩下的指数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 自乘递归求幂</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quickpow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//递归出口:指数为0，返回1</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = a;<br>    <span class="hljs-type">int</span> mindex = <span class="hljs-built_in">floor</span>(<span class="hljs-built_in">log2</span>(b));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index = <span class="hljs-number">1</span>; index &lt;= mindex; index++)<br>        result = (result * result) % p;<br>    b = b - (<span class="hljs-number">1</span> &lt;&lt; mindex);<span class="hljs-comment">//更新b，准备递归</span><br>    <span class="hljs-keyword">return</span> (result * <span class="hljs-built_in">quickpow</span>(a, b, p)) % p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b, p;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;<br>    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;^&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; mod &quot;</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; <span class="hljs-built_in">quickpow</span>(a, b, p) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试点结果：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032317333.png" alt="202411032317333.png"><br>成功AC了！<br>不过用了$log_{2}()$函数，可能还能对$log_{2}()$函数进行改变，比如使用位运算去计算不超过b的最大2的幂次，也就是找到b的二进制最高位。</p><h4 id="尝试：位运算找b二进制最高位-替代cmath库中log2函数"><a href="#尝试：位运算找b二进制最高位-替代cmath库中log2函数" class="headerlink" title="尝试：位运算找b二进制最高位,替代cmath库中log2函数"></a>尝试：位运算找b二进制最高位,替代cmath库中log2函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 自乘递归求幂</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quickpow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 递归出口:指数为0，返回1</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = a;<br>    <span class="hljs-type">int</span> mindex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((b &gt;&gt; mindex) != <span class="hljs-number">1</span>)<br>        mindex++; <span class="hljs-comment">// 逐步右移直到等于1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index = <span class="hljs-number">1</span>; index &lt;= mindex; index++)<br>        result = (result * result) % p;<br>    b = b - (<span class="hljs-number">1</span> &lt;&lt; mindex); <span class="hljs-comment">// 更新b，准备递归</span><br>    <span class="hljs-keyword">return</span> (result * <span class="hljs-built_in">quickpow</span>(a, b, p)) % p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b, p;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;<br>    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;^&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; mod &quot;</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; <span class="hljs-built_in">quickpow</span>(a, b, p) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试点结果：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032317766.png" alt="202411032317766.png"></p><h4 id="突发奇想：从找-2-left-log2-b-right-，转换成不大于b的最大2的幂次呢？"><a href="#突发奇想：从找-2-left-log2-b-right-，转换成不大于b的最大2的幂次呢？" class="headerlink" title="突发奇想：从找$2^{\left[log2(b)\right]}$，转换成不大于b的最大2的幂次呢？"></a>突发奇想：从找$2^{\left[log2(b)\right]}$，转换成不大于b的最大2的幂次呢？</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 求不大于b的最大2的幂次的快速算法(按位或运算快速1的扩散)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxpowerof2</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>                         <span class="hljs-comment">// 0010 1100 0000 0000 0000 0000 0000 0000 0000 0001</span><br>    x = x | (x &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-comment">// 0011 1110 0000 0000 0000 0000 0000 0000 0000 0000</span><br>    x = x | (x &gt;&gt; <span class="hljs-number">2</span>);    <span class="hljs-comment">// 0011 1111 1000 0000 0000 0000 0000 0000 0000 0000</span><br>    x = x | (x &gt;&gt; <span class="hljs-number">4</span>);    <span class="hljs-comment">// 0011 1111 1111 1000 0000 0000 0000 0000 0000 0000</span><br>    x = x | (x &gt;&gt; <span class="hljs-number">8</span>);    <span class="hljs-comment">// 0011 1111 1111 1111 1111 1000 0000 0000 0000 0000</span><br>    x = x | (x &gt;&gt; <span class="hljs-number">16</span>);   <span class="hljs-comment">// 0011 1111 1111 1111 1111 1111 1111 1111 1111 1111</span><br>    x = x | (x &gt;&gt; <span class="hljs-number">32</span>);   <span class="hljs-comment">// 0011 1111 1111 1111 1111 1111 1111 1111 1111 1111</span><br>    <span class="hljs-keyword">return</span> (x + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 0100 0000 0000 0000 0000 0000 0000 0000 0000 0000</span><br>                         <span class="hljs-comment">// 0010 0000 0000 0000 0000 0000 0000 0000 0000 0000</span><br>&#125;<br><span class="hljs-comment">// 自乘递归求幂</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quickpow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 递归出口:指数为0，返回1</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = a, btemp = b;<br>    <span class="hljs-type">int</span> mindex = <span class="hljs-built_in">maxpowerof2</span>(btemp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index = <span class="hljs-number">2</span>; index &lt;= mindex; index &lt;&lt;= <span class="hljs-number">1</span>)<br>        result = (result * result) % p;<br>    b = b - mindex; <span class="hljs-comment">// 更新b，准备递归</span><br>    <span class="hljs-keyword">return</span> (result * <span class="hljs-built_in">quickpow</span>(a, b, p)) % p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b, p;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;<br>    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;^&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; mod &quot;</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; <span class="hljs-built_in">quickpow</span>(a, b, p) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试点结果：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032318330.png" alt="202411032318330.png"><br>结果居然有一道题TLE了，说明存在不够快的问题，不过这个算法的思想还是值得学习的，比如利用按位或运算进行1的扩散快速求不大于b的最大2的幂次。<br>不够快的原因是什么呢？试验：将quickpow部分改成如下代码测试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quickpow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 递归出口:指数为0，返回1</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = a, btemp = b;<br>    <span class="hljs-type">int</span> mindex = <span class="hljs-built_in">log2</span>(<span class="hljs-built_in">maxpowerof2</span>(btemp));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index = <span class="hljs-number">1</span>; index &lt;= mindex; index++)<br>        result = (result * result) % p;<br>    b = b - (<span class="hljs-number">1</span> &lt;&lt; mindex); <span class="hljs-comment">// 更新b，准备递归</span><br>    <span class="hljs-keyword">return</span> (result * <span class="hljs-built_in">quickpow</span>(a, b, p)) % p;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试点结果：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032318720.png" alt="202411032318720.png"><br>居然都AC了，说明不是maxpowerof2的算法不够快，而是每次<code>index &lt;&lt;= 1</code>相比于<code>index++</code>慢，多次循环后导致超时。</p><h4 id="思路二小结"><a href="#思路二小结" class="headerlink" title="思路二小结"></a>思路二小结</h4><p>重新观察思路二发现主要的算法优化集中于剩下的$b-2^{\left[log2(b)\right]}$个的指数上，然后还发现算法的优化与二进制以及位运算息息相关，于是思考能否不让指数剩下，也就是把指数b用$a$、$a^{2}$、$a^{4}$、$a^{8}$、$a^{16}$，……，$a^{2^n}$ 充分的表示出来，而每一个都可以选或者不选对应着 $a^{1\times 2^n}$ 或者 $a^{0\times 2^n}&#x3D;1$(1在乘积中能维持式子值不变对应着不选该项)，那么如何把b用这2种项表示出来呢？思路三呼之欲出。</p><h3 id="思路三：二进制表示指数b，以拆分-a-b-为-a-0或1-times-2-n-的乘积"><a href="#思路三：二进制表示指数b，以拆分-a-b-为-a-0或1-times-2-n-的乘积" class="headerlink" title="思路三：二进制表示指数b，以拆分$a^{b}$为$a^{(0或1)\times{2^n}}$的乘积"></a>思路三：二进制表示指数b，以拆分$a^{b}$为$a^{(0或1)\times{2^n}}$的乘积</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quickpow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>)<br>            result = (result * a) % p; <span class="hljs-comment">// 如果b的当前位为1，则乘上a</span><br>        a = (a * a) % p; <span class="hljs-comment">// a自乘，更换乘积因子</span><br>        b &gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// b右移一位，准备下一次判断 b &amp; 1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b, p;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;<br>    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;^&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; mod &quot;</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; <span class="hljs-built_in">quickpow</span>(a, b, p) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试点结果：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032318949.png" alt="202411032318949.png"><br>成功AC!不禁感叹，没有递归处理剩余的$b-2^{\left[log2(b) \right]}$个指数的思路是多么的巧妙！究其原因是进制的唯一性，能够恰巧的将b精准的表示成$a^{1\times 2^n}$ 或者 $a^{0\times 2^n}&#x3D;1$的乘积，从而避免了递归处理剩余的$b-2^{\left[log2(b) \right]}$个指数。</p><p>从大思路来讲，我们从自下而上的乘的观念转变成了将b如何表示成这些乘的自上而下的视角，那么如果我们一开始没有一眼看到这种二进制的表示方法，那么我们将如何把b拆分呢？正过来是自乘平方，倒过来就是开方，换句话说是指数除以2，于是思路四呼之欲出。</p><h3 id="思路四：指数除以2，2分递归"><a href="#思路四：指数除以2，2分递归" class="headerlink" title="思路四：指数除以2，2分递归"></a>思路四：指数除以2，2分递归</h3><p>如果b为偶数，$a^{b}&#x3D;a^{b&#x2F;2}\times a^{b&#x2F;2}$，如果b为奇数，则再乘一个a，递归处理$a^{b&#x2F;2}$，直到$b&#x3D;0$，返回1，结束递归。当然也可以写成奇偶统一的形式：$a^{b}&#x3D;a^{b&#x2F;2}\times a^{b&#x2F;2}\times a^{b%2}$。代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quickpow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 递归出口:指数为0，返回1</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-built_in">quickpow</span>(a, b / <span class="hljs-number">2</span>, p); <span class="hljs-comment">// 递归处理指数b/2</span><br>    result = (result * result) % p; <span class="hljs-comment">// 指数为偶数</span><br>    <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) <span class="hljs-comment">//位运算判断b是否为奇数</span><br>        result = (result * a) % p; <span class="hljs-comment">// 指数为奇数，再乘一个a</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b, p;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;<br>    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;^&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; mod &quot;</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; <span class="hljs-built_in">quickpow</span>(a, b, p) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试点结果：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032318894.png" alt="202411032318894.png"><br>成功AC!看来自上而下的想法，即指数除以2，也是可行的，而且代码实现起来也很简单，不过这种思路的缺点是递归的深度太深：本质原因是未能一眼看出b如何充分乘积表示，而是用递归只看了一步二分表示，从而导致递归深度太深。那就多分一点，减少递归深度，于是思路五呼之欲出。</p><h3 id="思路五：2分可以递归，3分4分呢？"><a href="#思路五：2分可以递归，3分4分呢？" class="headerlink" title="思路五：2分可以递归，3分4分呢？"></a>思路五：2分可以递归，3分4分呢？</h3><p>既然2分可以递归，那么3分也可以递归，甚至n分也可以递归，然后递归处理$a^{b&#x2F;n}$，直到$b&#x3D;0$，返回1，结束递归。代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quickpow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">// 递归出口:指数为0，返回1</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-built_in">quickpow</span>(a, b / <span class="hljs-number">3</span>, p); <span class="hljs-comment">// 递归处理指数b/3</span><br>    result = ((result * result) % p * result) % p;<br>    <span class="hljs-keyword">if</span> (b % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>)<br>        result = (result * a) % p;<br>    <span class="hljs-keyword">if</span> (b % <span class="hljs-number">3</span> == <span class="hljs-number">2</span>)<br>        result = ((result * a) % p * a) % p;<span class="hljs-comment">//小心每乘一次都要取模不然会wa</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b, p;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;<br>    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;^&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; mod &quot;</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; <span class="hljs-built_in">quickpow</span>(a, b, p) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试点结果<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032318305.png" alt="202411032318305.png"><br>发现，三分比二分还快！原因就在于，三分的递归深度比二分浅，但是每次递归的计算量比二分多，在这两个方面的博弈下，三分比二分快一点点。当然，如果分更多，比如四分，那么递归深度会更浅，但是每次递归的计算量也会更多，所以分多少，我们还需要分析。<br>类似的四分的结果：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032318643.png" alt="202411032318643.png"><br>都AC了，而且比三分还快！说明在n分的n比较小的情况下，n越大，递归深度变浅的影响大于每次递归计算量变多的影响。</p><h3 id="思路六：n分呢？对n进行试验"><a href="#思路六：n分呢？对n进行试验" class="headerlink" title="思路六：n分呢？对n进行试验"></a>思路六：n分呢？对n进行试验</h3><p>写成n分的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n = <span class="hljs-number">5</span>;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quickpow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">// 递归出口:指数为0，返回1</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> temp = <span class="hljs-built_in">quickpow</span>(a, b / n, p); <span class="hljs-comment">// 递归处理指数b/n</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        result = (result * temp) % p;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b % n; i++)<br>        result = (result * a) % p; <span class="hljs-comment">// 处理指数b%n</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b, p;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;<br>    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;^&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; mod &quot;</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; <span class="hljs-built_in">quickpow</span>(a, b, p) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试点结果：<br>n&#x3D;5<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032319982.png" alt="202411032319982.png"><br>n&#x3D;10<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032319810.png" alt="202411032319810.png"><br>n&#x3D;50<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032319978.png" alt="202411032319978.png"><br>n&#x3D;100<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032320704.png" alt="202411032320704.png"><br>n&#x3D;500<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032321786.png" alt="202411032321786.png"><br>我们可以看到100分的表现还不错，但到500分的时候表现就不是很好了，说明分太多，递归深度变浅，但是每次递归计算量变多的影响也变大，导致整体效率下降。所以，分多少的最佳值n能不能提前预判呢？答案是肯定的，我们可以通过计算递归深度和每次递归计算量来预判n的最佳值。</p><h4 id="n分递归的理论分析：最佳值n的提前预判计算"><a href="#n分递归的理论分析：最佳值n的提前预判计算" class="headerlink" title="n分递归的理论分析：最佳值n的提前预判计算"></a>n分递归的理论分析：最佳值n的提前预判计算</h4><p>递归深度：$floor(log_n(b))$</p><p>每次递归计算量：$n$</p><p>总的时间复杂度：$O(n\cdot log_n(b))$<br>即$b\cdot\frac {n}{ln(n)}$</p><p>因此希望时间复杂度最小，也就是求$\frac {n}{ln(n)}$的最小值</p><p>因此求导得$\frac {ln(n)-1}{ln^2(n)}$，令其为0，解得n&#x3D;e，即n&#x3D;2.718281828459045，取整为3，所以n的最佳理论值为3。从上面的测试结果来看，n&#x3D;3时，效率确实相对较高。因此打破对2分的固有认知，事实上3分、4分效率比二分更高。</p><p>而因为联想到2分对应着二进制，3分对应着三进制，4分对应着四进制，所以n分对应着n进制，因此，我们可以将快速幂的指数进制表示算法扩展到任意进制的快速幂算法，即任意进制快速幂算法。</p><p>而且我们大胆推测，3进制的快速幂算法，应该比2进制更快，不妨试试。</p><h3 id="思路七：3进制快速幂，看看是否比2进制快"><a href="#思路七：3进制快速幂，看看是否比2进制快" class="headerlink" title="思路七：3进制快速幂，看看是否比2进制快"></a>思路七：3进制快速幂，看看是否比2进制快</h3><p>任意进制快速幂算法的思路是，将指数b转换为n进制表示，然后从低位到高位，依次处理指数的每一位，计算$a^{b_i\cdot n^{i-1}}$，然后将这些结果相乘，得到$a^b$。如果n&#x3D;3，代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quickpow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (b % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) <span class="hljs-comment">// 检查b的当前位（三进制下的个位）</span><br>            result = (result * a) % p;<br>        <span class="hljs-keyword">if</span> (b % <span class="hljs-number">3</span> == <span class="hljs-number">2</span>)<br>            result = ((result * a) % p * a % p) % p;<br>        a = ((a * a) % p * a) % p; <span class="hljs-comment">// a=a*a*a，更换乘积因子</span><br>        b /= <span class="hljs-number">3</span>;                    <span class="hljs-comment">// b除以3，准备下一次判断 b % 3</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b, p;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;<br>    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;^&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; mod &quot;</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; <span class="hljs-built_in">quickpow</span>(a, b, p) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试点结果<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032321718.png" alt="202411032321718.png"></p><p>成功的AC，而且和三分的效率相当，并且都比2进制或者二分快。这也正好符合我们刚刚的n分递归最佳n的理论分析。</p><h3 id="思路八：n进制快速幂呢？不妨对n进行实验！"><a href="#思路八：n进制快速幂呢？不妨对n进行实验！" class="headerlink" title="思路八：n进制快速幂呢？不妨对n进行实验！"></a>思路八：n进制快速幂呢？不妨对n进行实验！</h3><p>n进制快速幂代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n = <span class="hljs-number">4</span>; <br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quickpow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b % n; i++)<span class="hljs-comment">//提取b的当前位（n进制下的个位）</span><br>            result = (result * a) % p;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> temp = a;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; i++)<br>            a = (a * temp) % p;<span class="hljs-comment">//自乘n-1次，更换乘积因子</span><br>        b /= n;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b, p;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;<br>    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;^&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; mod &quot;</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; <span class="hljs-built_in">quickpow</span>(a, b, p) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>测试点结果：<br>n&#x3D;2<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032322885.png" alt="202411032322885.png"><br>n&#x3D;3<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032322150.png" alt="202411032322150.png"><br>n&#x3D;4<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032322046.png" alt="202411032322046.png"><br>n&#x3D;5<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032322635.png" alt="202411032322635.png"><br>不难发现，实验结果依然是n&#x3D;4最快，与递归中4分递归也是最快的是一致的。<br>因此又一次论证了2不是最快的，理论和实践证明3比2快，实践证明4甚至更快！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本质上，一共只有2个大思路：</p><ol><li>第一个是自下而上的想法，先自乘平方，再对剩下的递归，由于没有把b精准的分解，而是有剩下的指数，因此代码的实现度较低。</li><li>第二个是自上而下的想法，而这个大思路中又分为两个小思路：<ol><li>n分递归法，运用递归我们不需要一步看清b的最终分解方式，只需要对指数n分递归即可，实现度较高。</li><li>n进制快速幂法，运用进制转换，我们一步看清了b的最终分解方式，因此代码更简洁效率也高，思维度也较高。<br>最终我们通过试验结合对复杂度$O(n\cdot log_n(b))$的最值分析，证明了3、4分递归和或者3、4进制快速幂具有更快的速度，但是由于计算机中的数字是以2进制存储的，因此2进制快速幂的代码实现度最高更有利于用位运算操作，代码更简洁，因此常规的模版便是2进制快速幂！</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hicancan的科研周报10.25</title>
    <link href="/2024/11/07/10_25/"/>
    <url>/2024/11/07/10_25/</url>
    
    <content type="html"><![CDATA[<h1 id="10-18-10-25科研学习"><a href="#10-18-10-25科研学习" class="headerlink" title="10.18-10.25科研学习"></a>10.18-10.25科研学习</h1><h2 id="1-学习使用mmWave-studio采集毫米波雷达数据："><a href="#1-学习使用mmWave-studio采集毫米波雷达数据：" class="headerlink" title="1. 学习使用mmWave studio采集毫米波雷达数据："></a>1. 学习使用mmWave studio采集毫米波雷达数据：</h2><ul><li>安装所需软件：mmWave studio、MATLAB等。</li><li>了解其基本功能和使用方法。</li><li>学习雷达信号参数设置。</li><li>学习使用mmWave studio进行雷达信号可视化和分析。</li></ul><h2 id="2-阅读文献《基于车载毫米波雷达动态手势识别网络》"><a href="#2-阅读文献《基于车载毫米波雷达动态手势识别网络》" class="headerlink" title="2 阅读文献《基于车载毫米波雷达动态手势识别网络》"></a>2 阅读文献《基于车载毫米波雷达动态手势识别网络》</h2><h3 id="2-1-学习该研究方向的背景和意义"><a href="#2-1-学习该研究方向的背景和意义" class="headerlink" title="2.1 学习该研究方向的背景和意义"></a>2.1 学习该研究方向的背景和意义</h3><ul><li>相比于传统的图像手势识别：毫米波雷达可以通过发射电磁波并接收手势运动的回波来进行识别，因此可以不受光照影响，这是与图像手势识别相比的巨大优势。 同时毫米波雷达不需要采集车内图像信息，可以保护车内人员的隐私。</li></ul><h3 id="2-2-基于论文学习了动态手势识别算法数据处理"><a href="#2-2-基于论文学习了动态手势识别算法数据处理" class="headerlink" title="2.2 基于论文学习了动态手势识别算法数据处理"></a>2.2 基于论文学习了动态手势识别算法数据处理</h3><ul><li>整个算法数据处理分为三个部分：</li></ul><ol><li>原始数据采集：使用毫米波雷达采集动态手势数据。</li><li>数字信号处理：对采集到的数据进行滤波、去噪等处理。</li><li>动态手势分类网络识别：从预处理后的数据中提取有用的特征，并使用深度学习算法进行手势分类。<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032330715.png" alt="202411032330715.png"></li></ol><h3 id="2-3-学习了文中提出的动态手势识别网络模型"><a href="#2-3-学习了文中提出的动态手势识别网络模型" class="headerlink" title="2.3 学习了文中提出的动态手势识别网络模型"></a>2.3 学习了文中提出的动态手势识别网络模型</h3><ul><li>动态手势识别网络分为四个部分：</li></ul><ol><li>网络输入：距离-角度图RAM+距离-多普勒图RDM。</li><li>特征提取：经过两个3DCNN主干网络进行空间特征提取。</li><li>时间序列分析：利用Transformer编码器用来进行时序特征提取。</li><li>手势分类结果概率预测：经过一个全链接层进行分类。<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032330751.png" alt="202411032330751.png"><br>该网络模型的亮点：三维卷积网络（3DCNN）与Transformer的融合：通过将三维卷积网络用于空间特征提取，再结合Transformer模块进行时序特征编码，该模型能够同时捕捉手势的空间和时间特征，提高了识别的准确性。</li></ol><h3 id="2-4-学习如何提高数据集的多场景性以提高模型的泛化能力"><a href="#2-4-学习如何提高数据集的多场景性以提高模型的泛化能力" class="headerlink" title="2.4 学习如何提高数据集的多场景性以提高模型的泛化能力"></a>2.4 学习如何提高数据集的多场景性以提高模型的泛化能力</h3><ol><li>考虑汽车：在加速、减速、怠速、匀速与转弯等各种场景产生的震动而带来的惯性干扰。</li><li>考虑人：避免车内人员换挡、转身等非指令动态被误识别。</li><li>考虑环境：避免车内外的其他环境噪声的动态变化也会对数据采集造成干扰</li></ol><h3 id="2-5-思考意义：RDM与RAM特征图处理前后以及对比实验结果"><a href="#2-5-思考意义：RDM与RAM特征图处理前后以及对比实验结果" class="headerlink" title="2.5  思考意义：RDM与RAM特征图处理前后以及对比实验结果"></a>2.5  思考意义：RDM与RAM特征图处理前后以及对比实验结果</h3><p><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032330376.png" alt="202411032330376.png"><br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032330314.png" alt="202411032330314.png"><br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411032330090.png" alt="202411032330090.png"><br>因此：</p><ul><li>该文提出的算法达到了最高的平均分类精度97.14%，远好于传统的HMM算法. 仅采用3DCNN网络的分类准确率只有93.34%，</li><li>当加入LSTM和Transformer模块手势分类精度明显提高. 在3DCNN中添加Transformer模块要比LSTM模块分类准确率也增加1.1%</li><li>证明了Transformer模块的时序和空间编码方式在该分类任务中要优于LSTM网络</li></ul><h3 id="2-6-阅读小结"><a href="#2-6-阅读小结" class="headerlink" title="2.6 阅读小结"></a>2.6 阅读小结</h3><ul><li>该文提出的基于毫米波雷达的动态手势识别算法，通过将3DCNN与Transformer模块相结合，实现了对动态手势的高精度识别。同时，该算法在处理数据时考虑了车内环境、人、汽车等影响因素，提高了数据集的多场景性，从而提高了模型的泛化能力。</li><li>该文提出的算法在动态手势识别任务中取得了较好的效果，为未来基于毫米波雷达的动态手势识别研究提供了新的思路和方法。</li></ul><h3 id="2-7-与WiFi结合的可能性以及论文迁移创想应用"><a href="#2-7-与WiFi结合的可能性以及论文迁移创想应用" class="headerlink" title="2.7 与WiFi结合的可能性以及论文迁移创想应用"></a>2.7 与WiFi结合的可能性以及论文迁移创想应用</h3><ul><li>该文提出的基于毫米波雷达的动态手势识别算法，可以迁移到基于WiFi的动态手势识别算法中，通过将WiFi信号处理后的特征图作为输入，利用3DCNN与Transformer模块进行手势识别，从而实现基于WiFi的动态手势识别。</li><li>可以尝试多模态融合，将毫米波雷达和WiFi信号处理后的特征图进行融合，利用3DCNN与Transformer模块进行手势识别，从而实现多模态的动态手势识别。</li><li>还可以应用于智能家居、智能驾驶等领域，为用户提供更加便捷、智能的服务。例如，在智能家居中，可以通过动态手势识别技术实现遥控家电、调节灯光等功能，从而更好的保护用户隐私，并避免光照影响。</li></ul><h3 id="2-8-查找代码进行学习"><a href="#2-8-查找代码进行学习" class="headerlink" title="2.8 查找代码进行学习"></a>2.8 查找代码进行学习</h3><ul><li>由于该文是发表在期刊上的，因此没有提供代码，需要自己查找。</li><li>复现过程中需要了解3DCNN、Transformer等深度学习模型的基本原理和实现方法，同时需要了解毫米波雷达信号处理的基本方法。</li><li>复现过程中需要使用Python编程语言，并使用PyTorch等深度学习框架进行模型的实现和训练。</li><li>复现过程中需要使用MATLAB等软件进行毫米波雷达信号的处理和分析。</li><li>复现过程中需要使用mmWave studio等软件进行毫米波雷达信号的采集和可视化。<br>查找学习3DCNN代码如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicBlock</span>(nn.Module):<br>    expansion = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, in_planes, planes, stride=<span class="hljs-number">1</span></span>):<br>        <span class="hljs-built_in">super</span>(BasicBlock, <span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-variable language_">self</span>.conv1 = nn.Conv3d(in_planes, planes, kernel_size=<span class="hljs-number">3</span>, stride=stride, padding=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>)<br>        <span class="hljs-variable language_">self</span>.bn1 = nn.BatchNorm3d(planes)<br>        <span class="hljs-variable language_">self</span>.conv2 = nn.Conv3d(planes, planes, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>)<br>        <span class="hljs-variable language_">self</span>.bn2 = nn.BatchNorm3d(planes)<br><br>        <span class="hljs-variable language_">self</span>.shortcut = nn.Sequential()<br>        <span class="hljs-keyword">if</span> stride != <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> in_planes != <span class="hljs-variable language_">self</span>.expansion*planes:<br>            <span class="hljs-variable language_">self</span>.shortcut = nn.Sequential(<br>                nn.Conv3d(in_planes, <span class="hljs-variable language_">self</span>.expansion*planes, kernel_size=<span class="hljs-number">1</span>, stride=stride, bias=<span class="hljs-literal">False</span>),<br>                nn.BatchNorm3d(<span class="hljs-variable language_">self</span>.expansion*planes)<br>            )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        out = F.relu(<span class="hljs-variable language_">self</span>.bn1(<span class="hljs-variable language_">self</span>.conv1(x)))<br>        out = <span class="hljs-variable language_">self</span>.bn2(<span class="hljs-variable language_">self</span>.conv2(out))<br>        out += <span class="hljs-variable language_">self</span>.shortcut(x)<br>        out = F.relu(out)<br>        <span class="hljs-keyword">return</span> out<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ResNet</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, block, num_blocks, num_classes=<span class="hljs-number">10</span></span>):<br>        <span class="hljs-built_in">super</span>(ResNet, <span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-variable language_">self</span>.in_planes = <span class="hljs-number">64</span><br><br>        <span class="hljs-variable language_">self</span>.conv1 = nn.Conv3d(<span class="hljs-number">3</span>, <span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>)<br>        <span class="hljs-variable language_">self</span>.bn1 = nn.BatchNorm3d(<span class="hljs-number">64</span>)<br>        <span class="hljs-variable language_">self</span>.layer1 = <span class="hljs-variable language_">self</span>._make_layer(block, <span class="hljs-number">64</span>, num_blocks[<span class="hljs-number">0</span>], stride=<span class="hljs-number">1</span>)<br>        <span class="hljs-variable language_">self</span>.layer2 = <span class="hljs-variable language_">self</span>._make_layer(block, <span class="hljs-number">128</span>, num_blocks[<span class="hljs-number">1</span>], stride=<span class="hljs-number">2</span>)<br>        <span class="hljs-variable language_">self</span>.layer3 = <span class="hljs-variable language_">self</span>._make_layer(block, <span class="hljs-number">256</span>, num_blocks[<span class="hljs-number">2</span>], stride=<span class="hljs-number">2</span>)<br>        <span class="hljs-variable language_">self</span>.layer4 = <span class="hljs-variable language_">self</span>._make_layer(block, <span class="hljs-number">512</span>, num_blocks[<span class="hljs-number">3</span>], stride=<span class="hljs-number">2</span>)<br>        <span class="hljs-variable language_">self</span>.linear = nn.Linear(<span class="hljs-number">512</span>*block.expansion, num_classes)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_make_layer</span>(<span class="hljs-params">self, block, planes, num_blocks, stride</span>):<br>        strides = [stride] + [<span class="hljs-number">1</span>]*(num_blocks-<span class="hljs-number">1</span>)<br>        layers = []<br>        <span class="hljs-keyword">for</span> stride <span class="hljs-keyword">in</span> strides:<br>            layers.append(block(<span class="hljs-variable language_">self</span>.in_planes, planes, stride))<br>            <span class="hljs-variable language_">self</span>.in_planes = planes * block.expansion<br>        <span class="hljs-keyword">return</span> nn.Sequential(*layers)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        out = F.relu(<span class="hljs-variable language_">self</span>.bn1(<span class="hljs-variable language_">self</span>.conv1(x)))<br>        out = <span class="hljs-variable language_">self</span>.layer1(out)<br>        out = <span class="hljs-variable language_">self</span>.layer2(out)<br>        out = <span class="hljs-variable language_">self</span>.layer3(out)<br>        out = <span class="hljs-variable language_">self</span>.layer4(out)<br>        out = F.avg_pool3d(out, <span class="hljs-number">4</span>)<br>        out = out.view(out.size(<span class="hljs-number">0</span>), -<span class="hljs-number">1</span>)<br>        out = <span class="hljs-variable language_">self</span>.linear(out)<br>        <span class="hljs-keyword">return</span> out<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ResNet18</span>():<br>    <span class="hljs-keyword">return</span> ResNet(BasicBlock, [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure>解释代码：</li><li>该代码实现了一个基于3DCNN的动态手势识别算法，使用了ResNet18网络结构。</li><li>BasicBlock是ResNet的基本模块，包含两个卷积层和一个shortcut连接。</li><li>ResNet是整个网络结构，包含一个卷积层、四个BasicBlock层和一个全连接层。</li><li>ResNet18是ResNet的一个变种，使用四个BasicBlock层。</li><li>forward函数是网络的前向传播过程，输入为三维张量，输出为手势类别。</li><li>可以根据需要修改网络结构，例如增加或减少卷积层、全连接层等。</li><li>可以尝试使用其他3DCNN模型，例如VGG、Inception等。<br>查找学习Transformer代码如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transformer</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, d_model, nhead, num_encoder_layers, num_decoder_layers, dim_feedforward, dropout=<span class="hljs-number">0.1</span></span>):<br>        <span class="hljs-built_in">super</span>(Transformer, <span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-variable language_">self</span>.transformer = nn.Transformer(d_model, nhead, num_encoder_layers, num_decoder_layers, dim_feedforward, dropout)<br>        <span class="hljs-variable language_">self</span>.encoder = nn.Linear(d_model, d_model)<br>        <span class="hljs-variable language_">self</span>.decoder = nn.Linear(d_model, d_model)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, src, tgt</span>):<br>        src = <span class="hljs-variable language_">self</span>.encoder(src)<br>        tgt = <span class="hljs-variable language_">self</span>.decoder(tgt)<br>        output = <span class="hljs-variable language_">self</span>.transformer(src, tgt)<br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure>解释代码：</li><li>该代码实现了一个基于Transformer的动态手势识别算法。</li><li>Transformer是整个网络结构，包含一个编码器、一个解码器和一个Transformer模块。编码器和解码器都是线性层。</li><li>forward函数是网络的前向传播过程，输入为源序列和目标序列，输出为解码后的序列。</li><li>可以根据需要修改网络结构，例如增加或减少Transformer层、编码器和解码器等。</li><li>可以尝试使用其他序列到序列模型，例如LSTM、GRU等。</li><li>可以尝试使用其他注意力机制，例如自注意力、交叉注意力等。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>3DCNN模型可以用于动态手势识别，具有较好的实时性和准确性。</li><li>Transformer模型可以用于动态手势识别，具有较好的并行性和长距离依赖性。</li><li>可以根据具体任务和数据集，选择合适的模型和参数进行训练和优化。</li></ul>]]></content>
    
    
    <categories>
      
      <category>科研周报</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hicancan&#39;s 0xGame Writeup</title>
    <link href="/2024/11/07/0xGamewpcancan/"/>
    <url>/2024/11/07/0xGamewpcancan/</url>
    
    <content type="html"><![CDATA[<h1 id="0xGame-2024-Week-1-Writeup"><a href="#0xGame-2024-Week-1-Writeup" class="headerlink" title="0xGame 2024 Week 1 Writeup"></a>0xGame 2024 Week 1 Writeup</h1><h2 id="hicancan’s-0xGame-Writeup"><a href="#hicancan’s-0xGame-Writeup" class="headerlink" title="hicancan’s 0xGame Writeup"></a>hicancan’s 0xGame Writeup</h2><h3 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h3><h4 id="0xGame2048"><a href="#0xGame2048" class="headerlink" title="0xGame2048"></a>0xGame2048</h4><ol><li>“通过一点也不可靠的途径，我们提前截获了0xGame2048的题目，据说这就是那时候的base编码?”</li><li>给了一个0xGame2048.txt文件，里面是一串乱码<br>Жఱ൲ඌיય೬ࢶЖۍךะtঋළม۹ρԊҽඹ</li><li>进过多个不同的base编码尝试后，猜测该字符串是由base2048编码的</li><li>搜索找到一个在线base2048解码工具<br><a href="https://nerdmosis.com/tools/encode-and-decode-base2048">https://nerdmosis.com/tools/encode-and-decode-base2048</a></li><li>利用该在线解码工具解码后得到flag<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052882.png" alt="alt text"></li><li>flag：0xGame{W3lc0me_t0_0xG4me!!!}</li></ol><h4 id="关注DK盾谢谢喵"><a href="#关注DK盾谢谢喵" class="headerlink" title="关注DK盾谢谢喵"></a>关注DK盾谢谢喵</h4><ol><li>“关注微信公众号, 发送 0xGame 2024 以获取 flag”<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052885.png" alt="alt text"></li><li>打开微信扫描二维码，关注后发送”0xGame 2024”，得到flag<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052886.png" alt="alt text"></li><li>flag：0xGame{W31c0m3_70_0x64m3_2024_5p0n50r3d_8y_dkdun}</li></ol><h4 id="我的世界基岩版"><a href="#我的世界基岩版" class="headerlink" title="我的世界基岩版(?"></a>我的世界基岩版(?</h4><ol><li>服务器：mc.st4rr.top:25526<br>版本：java 1.21 Fabric<br>“题目很简单，只是为了开个服务器给大家玩玩 :)<br>如果服务器崩了或者有问题欢迎到群里拷打出题人 :(<br>世界中铁轨为玩家所建，另外告示牌皆为玩家所编辑，切勿随意相信:(“</li><li>此地无银三百两，那必须找找告示牌哇，注意ve后_的为英语中的换行连字符<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052887.png" alt="alt text"></li><li>flag:0xGame{MC_SErver_4_CTFers}</li></ol><h3 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h3><h4 id="Caesar-Cipher"><a href="#Caesar-Cipher" class="headerlink" title="Caesar Cipher"></a>Caesar Cipher</h4><ol><li>密文：0yHbnf{Uif_Cfhjoojoh_Pg_Dszqup}<br>提示：凯撒加密。</li><li>搜索到凯撒加密解密在线工具：<a href="https://ctf.bugku.com/tool/caesar">https://ctf.bugku.com/tool/caesar</a></li><li>由于不知道偏移量所以需要枚举偏移量，偏移量为1-25<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052888.png" alt="alt text"><br>逐个尝试得到25个解密后的字符串，发现偏移量为1时解密后的字符串有意义</li><li>flag:0xGame{The_Beginning_Of_Crypto}</li></ol><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><ol><li><p>给了一段代码，尝试理解并补充注释如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入bytes_to_long函数，用于将字节串转换为长整数</span><br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> bytes_to_long<br><span class="hljs-comment"># 导入base64编码函数</span><br><span class="hljs-keyword">from</span> base64 <span class="hljs-keyword">import</span> b64encode<br><span class="hljs-comment"># 导入secret模块中的flag变量，这个变量应该是一个字符串，代表要处理的信息</span><br><span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> flag<br><br><span class="hljs-comment"># 将flag字符串编码为字节串</span><br>msg = flag.encode()<br><span class="hljs-comment"># 获取编码后的字节串长度</span><br>length = <span class="hljs-built_in">len</span>(msg)<br><br><span class="hljs-comment"># 确保字节串的长度可以被4整除，这样才能均匀地分成四个部分</span><br><span class="hljs-keyword">assert</span> length%<span class="hljs-number">4</span> == <span class="hljs-number">0</span><br><span class="hljs-comment"># 计算每个部分的长度</span><br>block = length//<span class="hljs-number">4</span><br><span class="hljs-comment"># 将字节串分成四个部分，每部分长度为block</span><br>m = [ msg[ block*(i) : block*(i+<span class="hljs-number">1</span>) ] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>) ]<br><br><span class="hljs-comment"># 第一部分直接赋值给m0</span><br>m0 = m[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 第二部分使用bytes_to_long转换为长整数，赋值给m1</span><br>m1 = bytes_to_long(m[<span class="hljs-number">1</span>])<br><span class="hljs-comment"># 第三部分转换为十六进制字符串，赋值给m2</span><br>m2 = m[<span class="hljs-number">2</span>].<span class="hljs-built_in">hex</span>()<br><span class="hljs-comment"># 第四部分使用base64编码，赋值给m3</span><br>m3 = b64encode(m[<span class="hljs-number">3</span>])<br><br><span class="hljs-comment"># 打印出每个部分的值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;m0 = <span class="hljs-subst">&#123;m0&#125;</span>\nm1 = <span class="hljs-subst">&#123;m1&#125;</span>\nm2 = <span class="hljs-subst">&#123;m2&#125;</span>\nm3 = <span class="hljs-subst">&#123;m3&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>分析：为了找出flag，我们需要对每个部分进行逆向操作。</p><ol><li>m0是原始的字节串的一部分。</li><li>m1是一个长整数，我们需要将其转换回字节串。</li><li>m2是一个十六进制字符串，我们需要将其转换回字节串。</li><li>m3是一个base64编码的字符串，我们需要对其进行解码。</li></ol></li><li><p>写出逆向解码代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><span class="hljs-keyword">from</span> base64 <span class="hljs-keyword">import</span> b64decode<br><span class="hljs-comment"># 根据注释中的示例输出，我们有：</span><br>m0 = <span class="hljs-string">b&#x27;0xGame&#123;73d7&#x27;</span><br>m1 = <span class="hljs-number">60928972245886112747629873</span><br>m2 = <span class="hljs-string">&#x27;3165662d393339332d3034&#x27;</span><br>m3 = <span class="hljs-string">b&#x27;N2YwZTdjNGRlMX0=&#x27;</span><br><br><span class="hljs-comment"># 将m1转换回字节串</span><br>m1_bytes = long_to_bytes(m1)<br><span class="hljs-comment"># 将m2的十六进制字符串转换回字节串</span><br>m2_bytes = <span class="hljs-built_in">bytes</span>.fromhex(m2)<br><span class="hljs-comment"># 将m3的base64编码解码回字节串</span><br>m3_bytes = b64decode(m3)<br><span class="hljs-comment"># 将所有部分合并回原始的flag字符串</span><br>flag_bytes = m0 + m1_bytes + m2_bytes + m3_bytes<br><span class="hljs-comment"># 将字节串解码为字符串</span><br>flag = flag_bytes.decode()<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure></li><li><p><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052890.png" alt="alt text"><br>编译运行得到flag：</p></li></ol><p>0xGame{73d72f64-7656-11ef-9393-047f0e7c4de1}</p><h4 id="Code-Vigenere"><a href="#Code-Vigenere" class="headerlink" title="Code-Vigenere"></a>Code-Vigenere</h4><ol><li>给了一段代码，尝试理解并补充注释如下<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从secret模块导入flag变量</span><br><span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> flag<br><span class="hljs-comment"># 从os模块导入urandom函数，用于生成随机字节串</span><br><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> urandom<br><span class="hljs-comment"># 从base64模块导入b64encode函数，用于对字节串进行base64编码</span><br><span class="hljs-keyword">from</span> base64 <span class="hljs-keyword">import</span> b64encode<br><br><span class="hljs-comment"># 定义Encrypt函数，参数为消息msg和密钥key</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Encrypt</span>(<span class="hljs-params">msg, key</span>):<br>    <span class="hljs-comment"># 获取密钥的长度</span><br>    Lenth = <span class="hljs-built_in">len</span>(key)<br>    <span class="hljs-comment"># 初始化结果字符串</span><br>    result = <span class="hljs-string">&#x27;&#x27;</span><br><br>    <span class="hljs-comment"># 定义大写字母和小写字母的起始ASCII值</span><br>    upper_base = <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)<br>    lower_base = <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>    <span class="hljs-comment"># 将密钥转换为大写，并将每个字符转换为其对应的ASCII值减去&#x27;A&#x27;的ASCII值</span><br>    KEY = [<span class="hljs-built_in">ord</span>(key.upper()[_]) - upper_base <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(Lenth)]<br><br>    <span class="hljs-comment"># 初始化索引</span><br>    index = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 遍历消息中的每个字符</span><br>    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> msg:<br>        <span class="hljs-comment"># 获取当前密钥字符对应的ASCII值</span><br>        tmp_key = KEY[index % Lenth] <br>        <span class="hljs-comment"># 如果当前字符不是字母，则直接添加到结果字符串</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> m.isalpha():<br>            result += m<br>            <span class="hljs-keyword">continue</span><br><br>        <span class="hljs-comment"># 如果当前字符是大写字母，进行加密</span><br>        <span class="hljs-keyword">if</span> m.isupper(): <br>            result += <span class="hljs-built_in">chr</span>(upper_base + (<span class="hljs-built_in">ord</span>(m) - upper_base + tmp_key) % <span class="hljs-number">26</span>)<br>        <span class="hljs-comment"># 如果当前字符是小写字母，进行加密</span><br>        <span class="hljs-keyword">else</span>: <br>            result += <span class="hljs-built_in">chr</span>(lower_base + (<span class="hljs-built_in">ord</span>(m) - lower_base + tmp_key) % <span class="hljs-number">26</span>)<br>        <span class="hljs-comment"># 索引增加</span><br>        index += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 返回加密后的结果字符串</span><br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-comment"># 生成随机密钥，长度为6字节，然后进行base64编码，取前5个字符作为密钥</span><br>key = b64encode(urandom(<span class="hljs-number">6</span>))[:<span class="hljs-number">5</span>].decode()<br><span class="hljs-comment"># 使用生成的密钥加密flag，并打印加密后的结果</span><br><span class="hljs-built_in">print</span>(Encrypt(flag,key))<br><span class="hljs-comment"># 注释中的字符串是加密后的flag为：</span><br><span class="hljs-comment"># 0lCcop&#123;oyd94092-g8mq-4963-88b6-4helrxdhm6q7&#125;</span><br></code></pre></td></tr></table></figure></li><li>分析：为了找出flag，首先我们需要5个字符的密钥，然后使用这个密钥对加密后的字符串进行解密。<br>由于我们确定题解的格式是0XGame{}，所以我们可以通过前五个字母的明文与密文的对应关系来推断出密钥。下面通过编程实现密钥的推断：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_key</span>(<span class="hljs-params">pt, ct</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    根据给定的明文和密文,计算Vigenère密码的密钥。</span><br><span class="hljs-string">    参数:</span><br><span class="hljs-string">    pt (str): 明文字符串。</span><br><span class="hljs-string">    ct (str): 密文字符串。</span><br><span class="hljs-string">    返回:</span><br><span class="hljs-string">    str: 计算出的密钥字符串。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    key = []  <span class="hljs-comment"># 初始化密钥列表，用于存储每个字符的密钥偏移量</span><br>    upper_base = <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)  <span class="hljs-comment"># 大写字母的ASCII起始值</span><br>    lower_base = <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)  <span class="hljs-comment"># 小写字母的ASCII起始值</span><br>    <span class="hljs-comment"># 遍历明文和密文的每个字符</span><br>    <span class="hljs-keyword">for</span> p, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(pt, ct):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p.isalpha():  <span class="hljs-comment"># 跳过非字母字符</span><br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> p.isupper():  <span class="hljs-comment"># 如果字符是大写字母</span><br>            p_val = <span class="hljs-built_in">ord</span>(p) - upper_base  <span class="hljs-comment"># 将字符转换为0-25的数值</span><br>            c_val = <span class="hljs-built_in">ord</span>(c) - upper_base  <span class="hljs-comment"># 同上</span><br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 如果字符是小写字母</span><br>            p_val = <span class="hljs-built_in">ord</span>(p) - lower_base<br>            c_val = <span class="hljs-built_in">ord</span>(c) - lower_base<br>        <span class="hljs-comment"># 计算密钥偏移量，使用模26确保结果在0-25之间</span><br>        key_offset = (c_val - p_val) % <span class="hljs-number">26</span><br>        <span class="hljs-comment"># 将偏移量转换回大写字母，并添加到密钥列表中</span><br>        key.append(<span class="hljs-built_in">chr</span>(upper_base + key_offset))<br>    <span class="hljs-comment"># 将密钥列表连接成字符串并返回</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(key)<br><span class="hljs-comment"># 给定的明文和密文</span><br>plaintext = <span class="hljs-string">&#x27;0xGame&#x27;</span><br>ciphertext = <span class="hljs-string">&#x27;0lCcop&#x27;</span><br><span class="hljs-comment"># 移除明文中的非字母字符</span><br>plaintext = <span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">str</span>.isalpha, plaintext))<br>ciphertext = <span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">str</span>.isalpha, ciphertext))<br><span class="hljs-comment"># 确保明文和密文长度相同</span><br><span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(plaintext) == <span class="hljs-built_in">len</span>(ciphertext)<br><span class="hljs-comment"># 计算密钥</span><br>key = calculate_key(plaintext, ciphertext)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;key =&quot;</span>, key)<br></code></pre></td></tr></table></figure>编译运行结果如下：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052891.png" alt="alt text"><br>key &#x3D; OWCCL</li><li>使用密钥解密加密后的字符串：<br>搜索得到Vigenere加密解密在线工具：<a href="https://ctf.bugku.com/tool/vigenere">https://ctf.bugku.com/tool/vigenere</a><br>利用key &#x3D; OWCCL进行解密，得到flag：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052892.png" alt="alt text"></li><li>得到flag:</li></ol><p>0xGame{acb94092-e8bc-4963-88f6-4fcadbbfb6c7}</p><h4 id="RSA-Baby"><a href="#RSA-Baby" class="headerlink" title="RSA-Baby"></a>RSA-Baby</h4><ol><li>给了一段代码，尝试理解并补充注释如下<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> bytes_to_long, getPrime  <span class="hljs-comment"># 导入Crypto.Util.number模块中的bytes_to_long和getPrime函数</span><br><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> md5  <span class="hljs-comment"># 导入哈希库中的md5函数，用于生成哈希值</span><br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint  <span class="hljs-comment"># 导入随机数生成函数，用于生成随机数</span><br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> invert, gcd  <span class="hljs-comment"># 导入gmpy2库中的invert和gcd函数，用于计算模逆和最大公约数</span><br><span class="hljs-comment"># 定义MD5哈希函数，用于生成输入m的MD5哈希值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">MD5</span>(<span class="hljs-params">m</span>):<br>    <span class="hljs-keyword">return</span> md5(<span class="hljs-built_in">str</span>(m).encode()).hexdigest()<br><span class="hljs-comment"># 定义RSA密钥生成函数，用于生成公钥和私钥</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">KeyGen</span>():<br>    Factor_BitLength = <span class="hljs-number">30</span>  <span class="hljs-comment"># 定义素数因子的位数，这里设置为30位</span><br>    q = getPrime(Factor_BitLength)  <span class="hljs-comment"># 生成一个30位的素数q</span><br>    p = getPrime(Factor_BitLength)  <span class="hljs-comment"># 生成一个30位的素数p</span><br>    N = p * q  <span class="hljs-comment"># 计算N，即公钥和私钥的模数，N=p*q</span><br>    <span class="hljs-comment"># 计算欧拉函数值phi(N)，用于生成公钥和私钥</span><br>    phi = (p-<span class="hljs-number">1</span>) * (q-<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 生成公钥和私钥</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        e = randint(<span class="hljs-number">1</span>, phi)  <span class="hljs-comment"># 在1到phi之间随机选择一个整数e</span><br>        <span class="hljs-keyword">if</span> gcd(e, phi) == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 如果e和phi互质，则e可以作为公钥的一部分</span><br>            d = <span class="hljs-built_in">int</span>(invert(e, phi))  <span class="hljs-comment"># 计算d，即私钥的一部分，d是e模phi的逆元</span><br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-comment"># 生成公钥和私钥，并返回</span><br>    Pub_Key = (N, e)  <span class="hljs-comment"># 公钥由模数N和加密指数e组成</span><br>    Prv_Key = (N, d)  <span class="hljs-comment"># 私钥由模数N和解密指数d组成</span><br>    <span class="hljs-keyword">return</span> Pub_Key, Prv_Key<br><span class="hljs-comment"># 调用KeyGen函数生成公钥和私钥</span><br>Pub, Prv = KeyGen()<br><span class="hljs-comment"># 提取公钥和私钥的参数</span><br>N = Pub[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 提取公钥的模数N</span><br>e = Pub[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 提取公钥的加密指数e</span><br>d = Prv[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 提取私钥的解密指数d</span><br><span class="hljs-comment"># RSA加密过程，生成随机消息m并加密</span><br>m = randint(<span class="hljs-number">1</span>, N)  <span class="hljs-comment"># 在1到N之间随机生成一个整数m作为消息</span><br>c = <span class="hljs-built_in">pow</span>(m, e, N)  <span class="hljs-comment"># 使用公钥(N, e)加密消息m，得到密文c</span><br><span class="hljs-comment"># 打印公钥、私钥和加密后的消息</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Pub_Key = <span class="hljs-subst">&#123;Pub&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Prv_Key = <span class="hljs-subst">&#123;Prv&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Encrypt_msg = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><span class="hljs-comment"># 假设已知加密消息c的值，这里给出示例值</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">Pub_Key = (547938466798424179, 80644065229241095)</span><br><span class="hljs-string">Prv_Key = (547938466798424179, 488474228706714247)</span><br><span class="hljs-string">Encrypt_msg = 344136655393256706</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># 使用MD5函数计算原始消息m的MD5哈希值，并构造flag</span><br>flag = <span class="hljs-string">&#x27;0xGame&#123;&#x27;</span> + MD5(m) + <span class="hljs-string">&#x27;&#125;&#x27;</span><br></code></pre></td></tr></table></figure></li><li>分析：我们可以首先使用RSA解密公式$m &#x3D; c^dmodN$<br> 来解密密文 c，得到原始消息 m。然后，我们计算 m 的MD5哈希值，并将其拼接到固定的字符串 ‘0xGame{‘ 后面，形成最终的flag，实现代码如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> md5<br><span class="hljs-comment"># 已知的值</span><br>N = <span class="hljs-number">547938466798424179</span><br>d = <span class="hljs-number">488474228706714247</span><br>c = <span class="hljs-number">344136655393256706</span><br><span class="hljs-comment"># RSA 解密</span><br>m = <span class="hljs-built_in">pow</span>(c, d, N)<br><span class="hljs-comment"># 计算m的MD5哈希值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">MD5</span>(<span class="hljs-params">m</span>):<br>    <span class="hljs-keyword">return</span> md5(<span class="hljs-built_in">str</span>(m).encode()).hexdigest()<br>m_hash = MD5(m)<br><span class="hljs-comment"># 构造flag</span><br>flag = <span class="hljs-string">&#x27;0xGame&#123;&#x27;</span> + m_hash + <span class="hljs-string">&#x27;&#125;&#x27;</span><br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure>编译运行结果如下：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052894.png" alt="alt text"></li><li>得到flag：<br>0xGame{6e5719c54cdde25ce7124e280803f938}</li></ol><h3 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h3><h4 id="test-your-nc"><a href="#test-your-nc" class="headerlink" title="test your nc"></a>test your nc</h4><ol><li><p>“Prepare your netcat. Connect to server then you will get your first flag. nc 47.97.58.52 40000”由题目下载好netcat</p></li><li><p>cmd运行nercat连接到服务器的结果：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052895.png" alt="alt text"></p></li><li><p>得到flag：</p><p> 0xGame{928bb261-0a63-4389-b629-4d1f2f449848}</p></li></ol><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><h4 id="ez-login"><a href="#ez-login" class="headerlink" title="ez_login"></a>ez_login</h4><ol><li><p>题目给出一个网站<a href="http://47.76.151.192:60084/">http://47.76.151.192:60084</a><br> <img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052896.png" alt="alt text"></p></li><li><p>分析：有两个输入框，尝试使用burpsuite的intruder进行弱口令爆破密码：</p></li><li><p>首先用burpsuite内嵌浏览器访问网站，然后任意填写username和password点击login，抓包拦截：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052897.png" alt="alt text"><br>不妨猜测用户名为admin，添加payload位置到password，然后点击attack进行爆破：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052899.png" alt="alt text"><br>爆破得到密码为admin123</p></li><li><p>利用得到的用户名和密码登录网站，得到flag：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052900.png"></p></li><li><p>flag:</p><p> 0xGame{It_Is_Easy_Right?}</p></li></ol><h4 id="hello-http"><a href="#hello-http" class="headerlink" title="hello_http"></a>hello_http</h4><ol><li><p>题目给出一个网站<a href="http://8.130.84.100:50002/%EF%BC%9A">http://8.130.84.100:50002/：</a><br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052901.png" alt="alt text"></p></li><li><p>分析：尝试通过修改请求包伪装成xlcBrowser浏览器:python爬虫代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-comment"># 目标URL</span><br>url = <span class="hljs-string">&#x27;http://8.130.84.100:50002/&#x27;</span><br><span class="hljs-comment"># 伪装成x1cBrowser的headers</span><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;x1cBrowser&#x27;</span>,<br>&#125;<br><span class="hljs-comment"># 发送POST请求</span><br>response = requests.post(url, headers=headers)<br><span class="hljs-comment"># 打印响应内容</span><br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure></li><li><p>运行结果如下：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052903.png" alt="alt text"><br>于是用get方式传递hello&#x3D;world</p></li><li><p>此次类推，每一步修改都按照运行的结果进行：得到最终的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-comment"># 目标URL</span><br>url = <span class="hljs-string">&#x27;http://8.130.84.100:50002/&#x27;</span><br><span class="hljs-comment"># 伪装成x1cBrowser的headers</span><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;x1cBrowser&#x27;</span>,<br>    <span class="hljs-string">&#x27;Referer&#x27;</span>: <span class="hljs-string">&#x27;http://localhost:8080/&#x27;</span>,<br>    <span class="hljs-string">&#x27;X-Forwarded-For&#x27;</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span><br>&#125;<br><span class="hljs-comment"># GET请求的参数</span><br>params = &#123;<br>    <span class="hljs-string">&#x27;hello&#x27;</span>: <span class="hljs-string">&#x27;world&#x27;</span><br>&#125;<br><span class="hljs-comment"># POST请求的参数</span><br>data = &#123;<br>    <span class="hljs-string">&#x27;web&#x27;</span>: <span class="hljs-string">&#x27;security&#x27;</span><br>&#125;<br><span class="hljs-comment"># 设置cookie</span><br>cookies = &#123;<br>    <span class="hljs-string">&#x27;flag&#x27;</span>: <span class="hljs-string">&#x27;secret&#x27;</span><br>&#125;<br><span class="hljs-comment"># 发送POST请求</span><br>response = requests.post(url, headers=headers, data=data,params=params, cookies=cookies)<br><span class="hljs-comment"># 打印响应内容</span><br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure></li><li><p>运行结果如下：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052904.png" alt="alt text"></p></li><li><p>得到flag：</p><p> 0xgame{1cd6a904-725f-11ef-aafb-d4d8533ec05c}</p></li></ol><h4 id="hello-web"><a href="#hello-web" class="headerlink" title="hello_web"></a>hello_web</h4><ol><li>题目给出一个网站Flag<br><a href="http://8.130.84.100:50001/">http://8.130.84.100:50001/</a><br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052905.png" alt="alt text"></li><li>首先考虑查看源代码，发现右键后不行确定解题方向：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052906.png" alt="alt text"></li><li>尝试F12也不行<img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052907.png" alt="alt text"></li><li>尝试Ctrl+U查看源代码：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052908.png"></li><li>源代码中得到flag前半段：0xGame{ee7f2040-1987-4e0a<br>提示查看：“看看f14g.php”</li><li>所以考虑利用wireshark抓包查看请求包：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052909.png" alt="alt text"><br>找到flag后半段：-872d-68589c4ab3d3}</li><li>合并得到flag：0xGame{ee7f2040-1987-4e0a-872d-68589c4ab3d3}</li></ol><h3 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h3><h4 id="BabyBase"><a href="#BabyBase" class="headerlink" title="BabyBase"></a>BabyBase</h4><ol><li>题目给了一个BabyBase.exe文件，用Vscode中16进制编辑器查看：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052910.png"></li><li>找到flag附近的可疑的连续可解码的base64编码的字符片段：<br>MHhHYW1le04wd195MHVfa24wd19CNHNlNjRfRW5jMGQxbmdfdzNsbCF9</li><li>用base64在线解码工具进行解码：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052911.png" alt="alt text"></li><li>得到flag：<br>0xGame{N0w_y0u_kn0w_B4se64_Enc0d1ng_w3ll!}</li></ol><h4 id="BinaryMaster"><a href="#BinaryMaster" class="headerlink" title="BinaryMaster"></a>BinaryMaster</h4><ol><li>题目给了一个BinaryMaster.exe文件，用Vscode中16进制编辑器查看：找到flag：<br> <img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052912.png" alt="alt text"></li><li>flag：</li></ol><p>0xGame{114514cc-a3a7-4e36-8db1-5f224b776271}</p><h4 id="SignSign"><a href="#SignSign" class="headerlink" title="SignSign"></a>SignSign</h4><ol><li>题目给了一个Signin.exe文件，用Vscode中16进制编辑器查看：找到有关flag的片段：<br> <img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052913.png" alt="alt text"><br> <img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052914.png" alt="alt text"></li><li>flag被分在了两个片段，将他们合并得到flag：<br>0xGame{S1gn1n_h3r3_4nd_b3g1n_Reversing_n0w}</li></ol><h3 id="Blockchain"><a href="#Blockchain" class="headerlink" title="Blockchain"></a>Blockchain</h3><h4 id="肘，上链！"><a href="#肘，上链！" class="headerlink" title="肘，上链！"></a>肘，上链！</h4><ol><li>题目给了服务器端口、rcp、水龙头地址：<br>nc 156.238.233.7 20000<br>rpc <a href="http://156.238.233.7:8545/">http://156.238.233.7:8545</a><br>faucet 156.238.233.7:8080</li><li>在metamask中连接到网络，创建一个账户，然后使用水龙头地址输入自己的地址获取一些以太币：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052915.png" alt="alt text"><br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052917.png" alt="alt text"></li><li>用netcat连接到服务器：<br> <img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052918.png"><br> 按照要求给地址转账0.01个以太币：<img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052919.png" alt="alt text"><br> <img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052920.png"></li><li>转账确认成功后，再次连接服务器进入第2步：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052921.png"></li><li>要部署合约使得函数issolved()返回true，所以需要找到合约代码：再次连接服务器进入第4步查看合约代码：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052922.png" alt="alt text"></li><li>用RemixIDE相应的版本编译合约代码：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052923.png" alt="alt text"></li><li>输入合约地址：查看到两个函数<br> <img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052924.png" alt="alt text"></li><li>按照合约代码要求在sign函数右侧输入“Hello0xBlockchain”的256hash值，才能使issolved函数返回true，因此计算出hash值输入：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052925.png" alt="alt text"><br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052926.png" alt="alt text"></li><li>选择metamask账户，并点击sign提交哈希值，完成交易后，然后点击issolved查看返回值已经为true：<br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052927.png" alt="alt text"></li><li>然后再次连接服务器，进入第三步输入token得到flag：<br> <img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411071052928.png"></li><li>flag：<br>0xGame{T3st1ng_ur_bl0ckcha1n!}</li></ol>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由C语言实验报告引申的有趣极限题</title>
    <link href="/2024/11/07/3_1/"/>
    <url>/2024/11/07/3_1/</url>
    
    <content type="html"><![CDATA[<h1 id="关于斐波那契数列相邻项商的正负交替求和的极限"><a href="#关于斐波那契数列相邻项商的正负交替求和的极限" class="headerlink" title="关于斐波那契数列相邻项商的正负交替求和的极限"></a>关于斐波那契数列相邻项商的正负交替求和的极限</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>斐波那契数列定义如下：<br>$$<br>F_1&#x3D;0,F_2&#x3D;1,F_n&#x3D;F_{n-1}+F_{n-2}(n\geqslant 3)<br>$$<br>定义数列<br>$$<br>a_n&#x3D;\dfrac{F_{n+2}}{F_{n+1}}<br>$$<br>要求考察数列和$s_n$在n趋于无穷时的情况：<br>$$<br>s_n&#x3D;\sum_{i&#x3D;1}^{n}{(-1)^{n+1}a_i}&#x3D; \sum_{i&#x3D;1}^{n}{(-1)^{n+1} \dfrac{F_{n+2}}{F_{n+1}}}<br>$$<br>例如：<br>$$<br>s_1&#x3D;\dfrac{F_{3}}{F_{2}}&#x3D;\dfrac{2}{1}&#x3D;2<br>$$<br>$$<br>s_2&#x3D;\dfrac{F_{3}}{F_{2}}-\dfrac{F_{4}}{F_{3}}&#x3D;\dfrac{2}{1}- \dfrac{3}{2}&#x3D;\dfrac{1}{2}<br>$$<br>$$<br>s_3&#x3D;\dfrac{F_{3}}{F_{2}}-\dfrac{F_{4}}{F_{3}}+\dfrac{F_{5}}{F_{4}}&#x3D;\dfrac{2}{1}- \dfrac{3}{2}+\dfrac{5}{3}&#x3D;\dfrac{11}{6}<br>$$<br>$$<br>\cdots<br>$$<br>$$<br>s_n&#x3D;\dfrac{F_{3}}{F_{2}}-\dfrac{F_{4}}{F_{3}}+\dfrac{F_{5}}{F_{4}}-\dfrac{F_{6}}{F_{5}}+\cdots+(-1)^{n+1} \dfrac{F_{n+2}}{F_{n+1}}<br>$$</p><h2 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h2><h3 id="1-由于正负摆动，所以想先将正负相邻两项合并消除摆动"><a href="#1-由于正负摆动，所以想先将正负相邻两项合并消除摆动" class="headerlink" title="1.由于正负摆动，所以想先将正负相邻两项合并消除摆动"></a>1.由于正负摆动，所以想先将正负相邻两项合并消除摆动</h3><p>不妨找找规律<br>$$<br>a_1-a_2&#x3D;\dfrac{F_{3}}{F_{2}}-\dfrac{F_{4}}{F_{3}}&#x3D;\dfrac{2}{1} - \dfrac{3}{2}&#x3D;\dfrac{1}{1\times2}<br>$$<br>$$<br>a_3-a_4&#x3D;\dfrac{F_{5}}{F_{4}}-\dfrac{F_{6}}{F_{5}}&#x3D;\dfrac{5}{3}- \dfrac{8}{5}&#x3D;\dfrac{1}{3\times5}<br>$$<br>$$<br>a_5-a_6&#x3D;\dfrac{F_{7}}{F_{6}}-\dfrac{F_{8}}{F_{7}}&#x3D;\dfrac{13}{8}- \dfrac{21}{13}&#x3D;\dfrac{1}{8\times13}<br>$$<br>$$<br>\cdots<br>$$<br>不妨猜想：</p><p>$$<br>a_{2i-1}-a_{2i}&#x3D;\dfrac{F_{2i+1}}{F_{2i}}-\dfrac{F_{2i+2}}{F_{2i+1}}&#x3D;\dfrac{1}{F_{2i}\times F_{2i+1}}<br>$$</p><p>也就是要证明：<br>$$<br>F_{2i+1}\times F_{2i+1}-F_{2i}\times F_{2i+2}&#x3D;1<br>$$<br>而</p><p>$$<br>\begin{align*}<br>F_{2i+1}\times F_{2i+1}-F_{2i}\times F_{2i+2}<br>&amp;&#x3D; F_{2i+1}\times F_{2i+1}-F_{2i}\times (F_{2i+1}+F_{2i}) \<br>&amp;&#x3D; F_{2i+1}\times (F_{2i+1}-F_{2i})- F_{2i}\times F_{2i} \<br>&amp;&#x3D; F_{2i+1}\times F_{2i-1}-F_{2i}\times F_{2i}<br>\end{align*}<br>$$<br>即<br>$$<br>F_{2i+1}\times F_{2i+1}-F_{2i}\times F_{2i+2}&#x3D;F_{2i+1}\times F_{2i-1}-F_{2i}\times F_{2i}<br>$$<br>从而有<br>$$<br>F_{2i+1}\times F_{2i+1}-F_{2i}\times F_{2i+2}&#x3D;F_{2i-1}\times F_{2i-1}-F_{2i-2}\times F_{2i}<br>$$<br>从而有<br>$$<br>F_{2i+1}\times F_{2i+1}-F_{2i}\times F_{2i+2}&#x3D;F_{3}\times F_{3}-F_{2}\times F_{4}&#x3D;2\times 2-1\times 3&#x3D;1<br>$$</p><p>因此猜想成立，所以<br>$$<br>s_{2n-1}&#x3D; \sum_{i&#x3D;1}^{n}{\dfrac{1}{F_{2i}\times F_{2i+1}}}<br>$$</p><h3 id="2-写出通项公式"><a href="#2-写出通项公式" class="headerlink" title="2.写出通项公式"></a>2.写出通项公式</h3><p>因此，$s_{2n-1}$的通项公式为：<br>$$<br>s_{2n-1}&#x3D; \sum_{i&#x3D;1}^{n}{\dfrac{1}{F_{2i}\times F_{2i+1}}}&#x3D;\dfrac{1}{F_2\times F_3}+\dfrac{1}{F_4\times F_5}+\dfrac{1}{F_6\times F_7}+\cdots+\dfrac{1}{F_{2n}\times F_{2n+1}}<br>$$<br>$$<br>s_{2n}&#x3D; s_{2n-1}-\dfrac{F_{2n+2}}{F_{2n+1}}&#x3D; \sum_{i&#x3D;1}^{n}{\dfrac{1}{F_{2i}\times F_{2i+1}}}-\dfrac{F_{2n+3}}{F_{2n+2}}<br>$$<br>现在我们已经消除了正负号，现在我们只需证明$s_{2n-1}$的当n趋于无穷时收敛于一个定值a，即：<br>$$<br>\lim_{n\to\infty}{s_{2n-1}}&#x3D;\lim_{n\to\infty}{\dfrac{1}{F_2\times F_3}+\dfrac{1}{F_4\times F_5}+\dfrac{1}{F_6\times F_7}+\cdots+\dfrac{1}{F_{2n}\times F_{2n+1}}}&#x3D;a<br>$$<br>而此时自然的，由于斐波那契数列相邻两项商的极限为$\varphi&#x3D;\dfrac{1+\sqrt{5}}{2}\approx1.618034$，因此<br>$$<br>\lim_{n\to\infty}{s_{2n}}&#x3D;\lim_{n\to\infty}{s_{2n-1}}-\lim_{n\to\infty}{\dfrac{F_{2n+3}}{F_{2n+2}}}&#x3D;\lim_{n\to\infty}{s_{2n-1}}-\varphi&#x3D;a-\varphi<br>$$<br>而结合编程已经计算出极限的近似值：<br>奇数项和$s_{2n-1}\approx2.19596$<br>偶数项和$s_{2n}\approx0.577922$<br>验证：<br>$$<br>2.19596-1.618034\approx0.577922<br>$$<br>十分符合刚刚的论述！</p><h3 id="3-证明"><a href="#3-证明" class="headerlink" title="3.证明"></a>3.证明</h3><p>下面利用<br>由Binet公式：<br>$$<br>F_n&#x3D;\dfrac{\varphi^n-\psi^n}{\sqrt{5}}<br>$$</p><p>其中 $\varphi&#x3D;\dfrac{1+\sqrt{5}}{2} $， $\psi&#x3D;\dfrac{1-\sqrt{5}}{2} $<br>又：$\varphi&gt;1&gt;0&gt;\psi&gt;-1$<br>因此当n趋于无穷时$$\psi^n$$趋于0，而$\varphi^n$趋于无穷<br>因此<br>$$\lim_{n\to\infty}{F_n}&#x3D;\lim_{n\to\infty}{\dfrac{\varphi^n-\psi^n}{\sqrt{5}}}&#x3D;\lim_{n\to\infty}{\dfrac{\varphi^n}{\sqrt{5}}}$$<br>因此<br>$$<br>\lim_{n\to\infty}{\dfrac{1}{F_{2i}\times F_{2i+1}}}&#x3D;\lim_{n\to\infty}{\dfrac{\sqrt{5}}{\varphi^{2i}}\times\dfrac{\sqrt{5}}{\varphi^{2i+1}}}&#x3D;\lim_{n\to\infty}{\dfrac{5}{\varphi^{4i+1}}}<br>$$<br>因此：存在N，当n&gt;N时，使得：<br>$$<br>\begin{align*}<br>\lim_{n\to\infty}{s_{2n-1}}&amp;&#x3D;\lim_{n\to\infty}{\dfrac{1}{F_2\times F_3}+\dfrac{1}{F_4\times F_5}+\dfrac{1}{F_6\times F_7}+\cdots+\dfrac{1}{F_{2n}\times F_{2n+1}}} \<br>&amp;&#x3D;\lim_{n\to\infty}{\sum_{i&#x3D;1}^{n}{\dfrac{5}{\varphi^{4i+1}}}} \<br>\end{align*}<br>$$<br>因为其首项为$\dfrac{5}{\varphi^5}&gt;0$，公比为$0&lt;\dfrac{1}{\varphi^4}&lt;1$，求和收敛性显然成立。<br>又N为有限数，而当n&gt;N时，$\lim_{n\to\infty}{\sum_{i&#x3D;1}^{n}{\dfrac{5}{\varphi^{4i+1}}}}$收敛<br>因此$<br>\lim_{n\to\infty}{s_{2n-1}}<br>$收敛</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACM小图标哈哈哈</title>
    <link href="/2024/11/06/ACM/"/>
    <url>/2024/11/06/ACM/</url>
    
    <content type="html"><![CDATA[<h1 id="康康ACM小图标能不能加载出来哈哈哈"><a href="#康康ACM小图标能不能加载出来哈哈哈" class="headerlink" title="康康ACM小图标能不能加载出来哈哈哈~"></a>康康ACM小图标能不能加载出来哈哈哈~</h1><p><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411062311861.jpeg" alt="202411062311861.jpeg"></p>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Is ‘Rizz’ the Secret to Getting Ahead at Work?</title>
    <link href="/2024/11/06/Is%20%E2%80%98Rizz%E2%80%99%20the%20Secret%20to%20Getting%20Ahead%20at%20Work/"/>
    <url>/2024/11/06/Is%20%E2%80%98Rizz%E2%80%99%20the%20Secret%20to%20Getting%20Ahead%20at%20Work/</url>
    
    <content type="html"><![CDATA[<h1 id="Is-‘Rizz’-the-Secret-to-Getting-Ahead-at-Work-——“魅力”是在职场脱颖而出的秘诀吗"><a href="#Is-‘Rizz’-the-Secret-to-Getting-Ahead-at-Work-——“魅力”是在职场脱颖而出的秘诀吗" class="headerlink" title="Is ‘Rizz’ the Secret to Getting Ahead at Work?——“魅力”是在职场脱颖而出的秘诀吗?"></a>Is ‘Rizz’ the Secret to Getting Ahead at Work?——“魅力”是在职场脱颖而出的秘诀吗?</h1><blockquote><p>hicancan的英语阅读笔记</p></blockquote><hr><hr><h2 id="Background-Supplement【背景补充】"><a href="#Background-Supplement【背景补充】" class="headerlink" title="Background Supplement【背景补充】"></a>Background Supplement【背景补充】</h2><blockquote><blockquote><p><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411051504975.png" alt="{F45E7698-F509-42BD-B1F9-E1088EF4AB00}"><br>2023牛津词典年度热词‘Rizz’<br>英国牛津大学出版社12月4日公布，年轻人常用的网络俚语“Rizz”顺利脱颖而出，成为2023的牛津年度词汇。根据牛津大学出版社，“Rizz”含意为有魅力、具有吸引力及可以吸引浪漫及性伴侣。「Rizz」被视为“非凡的个人魅力”（charisma）一词的缩短版本。<br>例句：<br>「Dan might not be conventionally attractive,but he possesses some serious rizz—just look at how he’s charming those two models.」<br>「丹可能没有传统意义上的吸引力，但他拥有一些严肃的魅力——看看他是如何吸引那两个模特的。」<br>它也可以用作动词，用在“to rizz up”等俗语中，意思是吸引、引诱或与某人聊天。但是这个词是网络俚语，主要由年轻人在网络上使用。在TikTok上标签“rizz”的浏览量达到数十亿次。YouTube博主兼Twitch主播Kai Cenat被广泛认为是这词的普及者。今年这个词的使用量继续攀升，六月份，Buzzfeed向演员Tom Holland询问了他的rizz秘密。Tom Holland回答说：“我没有任何rizz，我的rizz有限。”然后解释说，他通过“持久战”赢得了女友Zendaya的芳心。<br><img src="https://p7.itc.cn/q_70/images03/20231213/6ee847242377403eb8a282fbe7840274.jpeg" alt="img"><br><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411051507460.webp"><br>这个采访后，“rizz”的使用更加频繁。牛津语言学院院长卡斯珀·格拉思沃尔(Casper Grathwohl)表示，这个词可能代表了“2023年的普遍情绪，即我们中的更多人在经历了充满挑战的几年后开始敞开心扉，对自己充满信心”。</p></blockquote></blockquote><hr><blockquote><p>cha·ris·ma n. &#x2F;kəˈrɪzmə&#x2F;<br>The President has great personal charisma.总统具有超凡的个人魅力。</p><p><strong>Clipping截短法构词：cha·ris·ma$\rightarrow$ris$\rightarrow$rizz</strong></p></blockquote><hr><hr><blockquote><h3 id="Whether-you-call-it-charisma-charm-or-magnetism【磁性；吸引力】-some-people-seem-like-naturals-【whether强调内涵】"><a href="#Whether-you-call-it-charisma-charm-or-magnetism【磁性；吸引力】-some-people-seem-like-naturals-【whether强调内涵】" class="headerlink" title="Whether you call it charisma, charm or magnetism【磁性；吸引力】, some people seem like naturals. 【whether强调内涵】"></a>Whether you call it charisma, charm or magnetism【磁性；吸引力】, some people seem like naturals. 【whether强调内涵】</h3><p><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411042331181.svg" alt="img"></p></blockquote><p>By Rachel Feintzeig</p><p>Mon, Jul 22, 2024 11:35am<img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411042332372.svg" alt="灰色时钟"> 4 min</p><p><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411041851798.png" alt="img"></p><h2 id="Good-news-It-can-be-learned"><a href="#Good-news-It-can-be-learned" class="headerlink" title="Good news: It can be learned"></a>Good news: It can be learned</h2><p>Great leaders have it. Gen Z has a new word for it【指rizz】. Can <strong>the rest of us</strong>【文章对象：泛指ordinary people】 learn it?</p><p><strong>【与副标题：”Good news: It can be learned.”问答对应，引出文章核心如何习得”rizz”】</strong></p><hr><blockquote><blockquote><table><thead><tr><th align="left"><strong>Generation</strong></th><th align="left"><strong>Time Frame</strong></th><th><strong>Age Now</strong></th></tr></thead><tbody><tr><td align="left">The Silent Generation</td><td align="left">1928-1945</td><td>79-96 years old</td></tr><tr><td align="left">Baby Boomers</td><td align="left">1946-1964</td><td>60-78 years old</td></tr><tr><td align="left">Gen X</td><td align="left">1965-1980</td><td>44-59 years old</td></tr><tr><td align="left">Millennials【千禧一代】</td><td align="left">1981-1996</td><td>28-43 years old</td></tr><tr><td align="left">Gen Z【Z世代；后浪】</td><td align="left">1997-2012</td><td>12-27 years old</td></tr><tr><td align="left">Gen Alpha</td><td align="left">Early 2010s-2025</td><td>0-approx. 11 years old</td></tr></tbody></table></blockquote></blockquote><hr><p>Charisma—or rizz , as current teenage slang【俚语】 has anointed【抹油使神圣化“镀金”】 it—can feel like an ephemeral【short-lived】 gift some【如”Great leaders”】 are just born with. The chosen【“天选之子”】 among us network and chitchat, exuding【exude散发】 warmth as they effortlessly hold court【成为众人瞩目的焦点】. <strong>Then</strong> there’s everyone else, agonising over【纠结于……】 exclamation points【！】 in email drafts and internally【in mind】 replaying that joke they made in the meeting, wondering if it hit【successful】.</p><p><strong>【泛象对比：rizz人以及非rizz：前者自信，后者精神内耗、overthinking、of mental internal friction（摩擦f）】</strong></p><p>“Well, this is awkward,” Mike <strong>Rizzo</strong>【正好包含rizz哈哈哈】, the head of a community for marketing operations professionals, says of rizz being crowned 2023 word of the year by the publisher of the Oxford English Dictionary. It’s so close to his last name, but so far from how he sees himself. He sometimes gets sweaty palms【手心出汗】 before hosting webinars【在线研讨会】.</p><p><strong>【具象对比：以Rizzo这个具体的人为例，指出非rizz人的awkward and nervous】</strong></p><hr><p>Who could blame us for obsessing over【对……思虑过度】 charisma, or lack thereof ? It can lubricate【promote】 social interactions, win us friends, and score promotions【获得晋升】. It’s also possible to cultivate【train】, assures【ensure】 Charles Duhigg, the author of a book about people he dubs【call】super communicators.</p><p><strong>【引出书，说明rizz的可培养性】</strong></p><p>At its heart, charisma isn’t about some grand performance. It’s a state we elicit【引出，得到】 in other people, Duhigg says. It’s about fostering【培养】 connection and making our conversation partners feel they’re the charming—or interesting or funny—ones.</p><p><strong>【指出rizz的本质：不在于表演而在于connection！】</strong></p><p>The key is to ask deeper, though not prying【窥探的】, questions that invite meaningful and revealing responses, Duhigg says. And <strong>match the other person’s vibes</strong>【共鸣】. Maybe they want to talk about emotions, the joy they felt watching their kid graduate from high school last weekend. 【一种是情感共鸣】Or maybe they’re just after <strong>straight-up</strong> logistics and want you to quickly tell them exactly how the team is going to turn around that presentation by tomorrow.【另一种是理性的分析直接帮助】</p><p><strong>【指出核心方法：match vibes！（其实换句话说能共鸣也可以说是有情商）】</strong></p><p>You might be hired into a company for your skill set【整套技能】, Duhigg says, <strong>but</strong> your ability to communicate and earn people’s trust propels【推动】 you up the ladder: “That is <strong>leadership</strong>.”</p><p><strong>【具体方法的职场体现】</strong></p><hr><hr><h2 id="Approachable-and-relatable【平易近人】"><a href="#Approachable-and-relatable【平易近人】" class="headerlink" title="Approachable and relatable【平易近人】"></a><strong>Approachable and relatable【平易近人】</strong></h2><p>In reporting this column, I was surprised to hear many executives【高管】 and professionals I find breezily confident and pleasantly chatty confess <strong>it wasn’t something that came naturally.</strong> They had to work on it.</p><p><strong>【下面以Dave MacLennan为例子讲述三个work on it的方法】</strong></p><p>Dave MacLennan , who served as chief executive of agricultural giant Cargill for nearly a decade, <strong>started</strong> by leaning into【喜欢】 a nickname: DMac, first bestowed upon him in a C-suite meeting where half the executives were named Dave.</p><p>He liked the informality【not formality】 of it. <strong>The further</strong> he ascended【上升】 up the corporate hierarchy【企业层级】, the more he strove【strive努力】 to be approachable and relatable.</p><p>Employees “need a reason to follow you,” he says. “One of the reasons they’re going to follow you is that they feel they know you.”</p><p><strong>【方法一：Make them feel they know you】</strong></p><hr><p>He makes a point to <strong>remember the details and dates of people’s lives</strong>, such as colleagues’ birthdays. After making his acquaintance, in a meeting years ago at The Wall Street Journal’s offices, I was shocked to receive an email from his address months later. Subject line: You , a heading so compelling I still recall it. He went on to say he remembered I was due with my first child any day now and just wanted to say good luck.</p><p>“So many people say, ‘Oh, I don’t have a good memory for that,’” he says. Prioritise【给予……优先权】 remembering, making notes on your phone if you need, he says.</p><p><strong>【方法二：Make yourself know them】</strong></p><hr><p>Now a board member【董事会成员】 and an executive coach, MacLennan sent hundreds of <strong>handwritten notes</strong> during his tenure【任期】. He’d reach out to midlevel managers who’d just gotten a promotion, or engineers who showed him around meat-processing plants. He’d pen words of thanks or congratulations. And he’d address the envelopes himself.</p><p>“<strong>Your handwriting is a very personal thing about you</strong>,” he says. “Think about it. Twenty seconds. It makes such an impact.”</p><p><strong>【方法三：Take advantage of your own handwriting】</strong></p><hr><hr><h2 id="Everyone’s-important"><a href="#Everyone’s-important" class="headerlink" title="Everyone’s important"></a><strong>Everyone’s important</strong></h2><p>Doling out your charm selectively will backfire【事与愿违】, says Carla Harris , a Morgan Stanley executive. She chats up the woman cleaning the office, the receptionist at her doctor’s, the guy waiting alongside her for the elevator.</p><p><strong>【也就是Everyone’s important！不要selective！】</strong></p><p>“Don’t be confused,” she tells young bankers. Executive assistants are often the most powerful people in the building, and you <strong>never know</strong> how someone can help—or hurt—you down the line.</p><p><strong>【讲述了why everyone’s important，下面举例子】</strong></p><p>Harris once spent a year mentoring <strong>a junior worker in another department</strong>, not expecting anything in return. One day, Harris randomly mentioned she faced an uphill battle in meeting with a new client. Oh!, the 24-year-old said. <strong>Turns out</strong>, the client was her friend. She made the call right there, setting up Harris for a work win.</p><p><strong>【正所谓“帮助别人就是帮助自己”】</strong></p><p>In the office, stop staring at your phone, Harris advises, and notice the people around you. Ask for their names. Push yourself to start a conversation with three random people every day.</p><p><strong>【提出建议：how：chat with everyone】</strong></p><hr><hr><h2 id="Charisma-for-introverts【内向型人格】"><a href="#Charisma-for-introverts【内向型人格】" class="headerlink" title="Charisma for introverts【内向型人格】"></a><strong>Charisma for introverts【内向型人格】</strong></h2><p>You can’t will yourself to be a bubbly【多泡的哈哈哈形象】 extrovert【外向型人格】, <strong>but you can find your own brand of charisma</strong>, says Vanessa Van Edwards, a communications trainer and author of a book about charismatic communication.</p><p><strong>【方法一：Using nonverbal cues】</strong></p><p>For introverted clients, she recommends <strong>using nonverbal cues</strong>【非语言暗示】. A slow triple【三】 nod shows people you’re listening. Placing your hands in the steeple position, together and facing up, denotes【indicate】 that you’re calm and present.</p><p><strong>【方法二：Show your actual interests】</strong></p><p><strong>Try coming up with one question you’re known for.</strong> Not a canned【罐头装的&#x3D;老套的】, hokey【做作的】 ice-breaker, but something casual and simple that reflects your <strong>actual interests</strong>. One of her clients, a bookish executive struggling with uncomfortable, halting starts to his meetings, began kicking things off by asking “Reading anything good?”</p><hr><hr><h2 id="Embracing-your-stumbles【接纳错误】"><a href="#Embracing-your-stumbles【接纳错误】" class="headerlink" title="Embracing your stumbles【接纳错误】"></a><strong>Embracing your stumbles【接纳错误】</strong></h2><p>Charisma starts with confidence. It’s not that captivating【rizz&#x2F;charm&#x2F;appealing&#x2F;of charisma】 people don’t occasionally mispronounce a word or spill【洒】 their coffee, says Henna Pryor, who wrote a book about embracing awkwardness at work. They just have a faster comeback rate <strong>than</strong> the rest of us. They call out the stumble <strong>instead of</strong> trying to hide it, make a small joke, and move on.</p><p>Being perfectly polished all the time is <strong>not only</strong> exhausting【主观原因】, it’s impossible【客观原因】. We know this, which is why appearing flawless【完美无瑕】 can come off as fake. We like people who seem human, Pryor says.</p><p>Our most admired colleagues are often the ones who are good at their jobs and can laugh at themselves too, who occasionally trip or flub【搞糟，犯错误】 just like us.</p><p>“It creates this little moment of warmth,” she says, “that we actually find almost like a <strong>relief</strong>.”</p><p><strong>【指出本质：接纳不完美的自己是一种relief】</strong></p><hr><hr><p><img src="https://gcore.jsdelivr.net/gh/hicancan/piclist/202411041851559.svg" alt="img">Copyright 2020, Dow Jones &amp; Company, Inc. All Rights Reserved Worldwide. LEARN MORE</p><hr><hr><h2 id="Mind-map-summary【思维导图总结】"><a href="#Mind-map-summary【思维导图总结】" class="headerlink" title="Mind map summary【思维导图总结】"></a>Mind map summary【思维导图总结】</h2><pre><code class="mermaid">classDiagramClass01 &lt;|-- AveryLongClass : CoolClass03 *-- Class04Class05 o-- Class06Class07 .. Class08Class09 --&gt; C2 : Where am i?Class09 --* C3Class09 --|&gt; Class07Class07 : equals()Class07 : Object[] elementDataClass01 : size()Class01 : int chimpClass01 : int gorillaClass08 &lt;--&gt; C2: Cool label</code></pre>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Welcome my friends！</title>
    <link href="/2024/11/06/Welcome/"/>
    <url>/2024/11/06/Welcome/</url>
    
    <content type="html"><![CDATA[<h1 id="Welcome-to-hicancan-personal-blog-nice-to-meet-you"><a href="#Welcome-to-hicancan-personal-blog-nice-to-meet-you" class="headerlink" title="Welcome to hicancan personal blog, nice to meet you!"></a>Welcome to hicancan personal blog, nice to meet you!</h1><h2 id="建立这个博客的缘由十分有趣"><a href="#建立这个博客的缘由十分有趣" class="headerlink" title="建立这个博客的缘由十分有趣"></a>建立这个博客的缘由十分有趣</h2><p>在2024年11月5日，我突然想起来我的英语课前分享还没有做，然后结合前些阵子学习markdown写题解也想分享分享，突然想到，我为什么不写一个博客来呈现一下我的分享呢？于是我就开始搭建这个博客，并在2024年11月6日完成了这个博客的初步搭建。</p><h2 id="搭建的过程还是比较艰难的"><a href="#搭建的过程还是比较艰难的" class="headerlink" title="搭建的过程还是比较艰难的"></a>搭建的过程还是比较艰难的</h2><p>因为不想花钱想白嫖，所以就选择了github+hexo的方案，但是搭建的过程中遇到了很多问题，比如github的访问问题，hexo的配置问题，主题的配置问题等等，但是经过一番努力，终于有了个人博客的雏形。</p><h2 id="我希望我的博客能够帮助到更多的人"><a href="#我希望我的博客能够帮助到更多的人" class="headerlink" title="我希望我的博客能够帮助到更多的人"></a>我希望我的博客能够帮助到更多的人</h2><p>我希望我的博客能够帮助到更多的人，探讨学习经验和心得，让更多的人能够从中受益。同时，我也希望能够通过我的博客，结识更多的朋友，一起交流学习，共同进步哟~</p>]]></content>
    
    
    <categories>
      
      <category>welcome</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
